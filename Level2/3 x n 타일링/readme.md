```py
def solution(n):
    dp = [0] * (n+1)
    dp[1]= 3
    dp[3]= 11
    for i in range(2, n+1):
        if i % 2 == 0:
            dp[i] = dp[i-1]
        else:
            dp[i] = dp[i-1] + 2 * dp[i-2]
    return dp[-1]
```

- 처음에는 위와같이 dp로 풀면 될 것 같다고 생각했는데 실패했다.
- 여기서 힌트는 하나 홀수의 경우에는 성립하지 않는다는 것.
- n/2를 진행해 조건을 줄이고 점화식을 찾아본다.

```py
def solution(n):
    mod = 10**9+7
    # 홀수 제외
    n //= 2
    # 최초 값 설정
    dp = [0] * (n+1)
    dp[1]= 3
    dp[2]= 11
    for i in range(3, n+1):
            dp[i] = (3 * dp[i-1] + 2 * sum(dp[:i-1]) + 2) % mod
    return dp[-1]

```

- 위의 답안으로 통과했다.
- 우선 홀수의 경우는 제외한다.
- dp[1] 즉, n = 2인 경우와 dp[2 ] 즉, n = 4인 경우를 최초 값으로 설정하고 점화식을 도출해본다.
- 이러한 점화식을 통해서 dp[i] = (3 _ dp[i-1] + 2 _ sum(dp[:i-1]) + 2) 를 구할 수 있게 된다.
