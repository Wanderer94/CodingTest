- 처음에는 모든 경우의 수를 알아내야한다고 생각해서 bfs를 사용할까 고민했지만 전혀 구현되지 않았다.
- 해당 문제의 핵심은 1,2를 이용해서 수식을 만들고 그 결과가 N인 경우의 수를 모두 구하는것이다.
- 채우기 문제같지만 결국 수식문제, 여기서 DP를 고민하기 시작했지만 어떻게 적용시키는게 좋을지 고민이 되기 시작했다.
- 핵심은 가장작은 경우의 수 부터 고민해 보는것, 피보나치 처럼 구현해보려 하였다.

```py
 def DP(n):
        if n == 1:
            return 1
        elif n == 2:
            return 2
        else:
            return DP(n-1) + DP(n-2)
    return DP(n)
```

- 해당 코드를 돌렸더니 런타임 에러가 발생하였다.
- 이유는 메모리가 오버플로우 되어서 그런 것이라 생각이 들었다.
- 따라서 아래와 같이 메모이제이션을 사용한 코드로 답을 제출했고 통과했다.

```py
def solution(n):
    mod = 10**9+7
    dp  = [0]*(n+1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n+1):
        dp[i] = (dp[i-1]+dp[i-2])%mod
    return  dp[-1]
```

- 이유는 dp[n]을 구하는 과정에서 dp[i-1], dp[i-2]를 사용해야 하기 때문에, 이전의 결과를 저장해두어야 한다.
- 이렇게 하면 메모리가 오버플로우 되지 않고 정상적으로 계산할 수 있다.
- 또한 mod를 사용하여 10^9+7을 나누는 것으로 인해 런타임 에러가 발생하지 않게 되었다.
- 이렇게 하면 시간복잡도와 메모리사용량을 최적화할 수 있다.
